# 算法

### 前缀、中缀、后缀表达式
  - 定义:
    * 中缀表达式运算符位于操作数中间，是常用的算术表示方法。
    * 前缀表达式又称为波兰表达式，运算符位于操作数之前。
    * 后缀表达式又称为逆波兰表达式，运算符位于操作数之后。
  - 相互转化:
    * 中缀表达式转前缀表达式
      ```
      // 中缀表达式(3+4)*5-6转为前缀表达式就是-*+3456
      1. 初始化两个栈：运算符栈S1和存储中间结果的栈S2
      2. 从右至左扫描中缀表达式
      3. 遇到操作数时将其入栈S2
      4. 遇到运算符时，比较其与S1栈顶运算符的优先级；若S1为空或栈顶运算符为右括号')'则直接将此运算符入栈，否则若优先级比栈顶运算符高或相等(转为后缀表达式时是高没有相等)也将此运算符入栈S1，否则将S1栈顶的运算符弹出并入栈S2中，再次重复步骤4与S1中新的栈顶运算符相比较
      5. 遇到右括号')'则直接入栈S1；遇到左括号'('时，则依次弹出S1栈顶的运算符并入栈S2直到遇到右括号为止，此时将这一对括号丢弃
      6. 重复步骤2到步骤5直到表达式的最左边
      7. 将S1中剩余的运算符依次弹出并入栈S2
      8. 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式(转为后缀表达式需将字符串反转输出，转为前缀表达式直接输出)
      ```
    * 中缀表达式转后缀表达式
      ```
      // 中缀表达式(3+4)*5-6转为后缀表达式就是34+5*6-
      1. 初始化两个栈：运算符栈S1和存储中间结果的栈S2
      2.  从左至右扫描中缀表达式
      3.  遇到操作数时将其入栈S2
      4.  遇到运算符时，比较其与S1栈顶运算符的优先级；若S1为空或栈顶运算符为左括号'('则直接将此运算符入栈，否则若优先级比栈顶运算符高(转为前缀表达式时是优先级高或相等，转为后缀表达式则不包括相等)也将此运算符入栈S1，否则将S1栈顶的运算符弹出并入栈S2中，再次重复步骤4与S1中新的栈顶运算符相比较
      5.  遇到右括号')'，则依次弹出S1栈顶的运算符并入栈S2直到遇到左括号为止，此时将这一对括号丢弃
      6.  重复步骤2到步骤5直到表达式的最右边
      7.  将S1中剩余的运算符依次弹出并入栈S2
      8.  依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式(转换为前缀表达式时不用逆序)
      ``` 
    * 前缀表达式转中缀表达式
      ```
      // 前缀表达式-*+3456转为中缀表达式就是(3+4)*5-6
      1. 初始化存储中间结果的栈S2
      2. 从右至左扫描前缀表达式
      3. 遇到操作数时入栈S2
      4. 遇到运算符时就从栈S2中弹出两棵树T1和T2(T1为先弹出栈)并形成一棵新的树，该树根就是操作符，T1为左子树(先出的为左子树)，T2为右子树(后弹出的)，然后将这个树作为整体入栈S2，重复该步骤直到最左边。
      5. 对上面构造的表达式树按中序遍历(左根右，左子树和右子树用括号括起来作为一个整体)得出的结果即为中缀表达式
      ```
    * 后缀表达式转中缀表达式
      ```
      // 后缀表达式34+5*6-转为中缀表达式就是(3+4)*5-6
      1. 初始化存储中间结果的栈S2
      2. 从左至右扫描后缀表达式
      3. 遇到操作数时入栈S2
      4. 遇到运算符时就从栈S2中弹出两棵树T1和T2(T1为先弹出栈)并形成一棵新的树，该树根就是操作符，T1为左子树(先出的为左子树)，T2为右子树(后弹出的)，然后将这个树作为整体入栈S2，重复该步骤直到最右边。
      5. 对上面构造的表达式树按中序遍历(左根右，左子树和右子树用括号括起来作为一个整体)得出结果的逆序即为中缀表达式
      ```

### 深度优先遍历(Depth First Search, 简称DFS)
  - 定义：从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止
  - 实现
    ```
    // 1. 深度优先遍历的递归
    function deepTraversal(node) {
      let nodes = []
      if (node != null) {
        nodes.push[node]
        let childrens = node.children
        for (let i = 0, len = childrens.length;i < len; i++) {
          deepTraversal(childrens[i])
        }
      }
      return nodes
    }
    // 2. 深度优先遍历的非递归
    function deepTraversal(node) {
      let nodes = []
      if (node != null) {
        let stack = [] // 存放将来要访问的节点
        stack.push(node)
        while (stack.length != 0) {
          let item = stack.pop() // 正在访问的节点
          nodes.push(item)
          let childrens = item.children
          // 将现在访问点的节点的子节点存入stack，供将来访问
          for (let i = childrens.length - 1; i >= 0;i--) {
            stack.push(childrens[i])
          }
        }
      }
      return nodes
    }
    ```

### 广度优先遍历(Breath First Search, 简称BFS)
  - 定义：从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止
  - 实现
    ```
    // 1. 广度优先遍历的递归
    function wideTraversal(node) {
      let nodes = [], i = 0
      if (node != null) {
        nodes.push(node)
        wideTraversal(node.nextElementSibling)
        node = nodes[i++]
        wideTraversal(node.firstElementChild)
      }
      return nodes
    }
    // 2.广度优先遍历的非递归
    function wideTraversal(node) {
      let nodes = [],i = 0
      while (node != null) {
        nodes.push(node)
        node = nodes[i++]
        let childrens = node.children
        for (let i = 0, len = childrens.length; i < len; i++) {
          nodes.push(childrens[i])
        }
      }
      return nodes
    }
    ```