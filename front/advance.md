前端笔记-高级

#### DOM
  1. 当浏览器加载html页面时首先就是DOM结构的计算，计算出来的DOM结构就是DOM树(把页面中html标签像树状结构一样分析出之间的层级关系)。DOM树描述了标签间的关系(节点间的关系)，只要知道任何一个标签都可以依据DOM中提供的属性和方法获取到页面中任意一个标签或节点。

#### 构造函数-扩展
  1. var a = {}其实是var a = new Object()的语法糖。
  2. var a = []其实是var a = new Array()的语法糖。
  3. function foo(){...}其实是var foo = new Function(...)的语法糖。
  4. instanceof用于判断引用类型的变量属于哪个构造函数的一个方法(一个函数是否是一个变量的构造函数), f instanceof Foo的判断逻辑是f的__proto__一层一层往上能否对应到Foo.prototype。

#### new操作符具体做什么
  1. 创建一个空对象obj即{}。
  2. 将obj的__proto__属性指向构造函数constructor的原型即obj.__proto__ == obj.constructor.prototype。
  3. 将构造函数constructor内部的this绑定到新建的对象，执行constructor(也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constructor()一样)。
  4. 属性和方法被加入到this引用的对象中。
  5. 若构造函数没有返回非原始值(即不是引用类型的值)，则返回该新建的对象obj(默认会添加return this)。否则，返回引用类型的值。

#### 原型规则
  1. 所有的引用类型(数组，对象，函数)都具有对象特性，即可以自由扩展属性(null除外)。
  2. 所有的引用类型(数组，对象，函数)都有一个__proto__属性(隐式原型)，属性值是一个普通的对象。
  3. 所有的函数对象(Function)都有一个prototype属性(显式原型)，属性值也是一个普通对象，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1 = new Person(...)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor // true。prototype是从一个函数指向一个对象，它的含义是函数的原型对象，也就是这个函数(其实所有函数都可以作为构造函数)所创建的实例的原型对象。
  4. 所有的引用类型(数组，对象，函数)__proto__属性(隐式原型)值指向它的构造函数的prototype属性值(显式原型)。
   `var obj = {}; obj.__proto__ === Object.prototype; // true`
  5. 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。
  6. js为了避免死循环将Object.prototype的__proto__设为null。`Object.prototype.__proto__ === null // true`
  7. __proto__和constructor属性是对象所独有的，prototype属性是函数所独有的，由于js中函数也是一种对象，所以函数也拥有__proto__和constructor属性。constructor是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数(本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点)。Function对象比较特殊，它的构造函数就是它自己(因为Function可以看成是一个函数，也可以是一个对象)，所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。
  8. 每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显示定义的或通过__proto__在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建时js会同时创建一个该函数对应的prototype对象，而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor === 该函数本身，所以通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数。

#### js原型链
  1. 对象本质是一个hash表(存储键值对的表格);js内存分为代码区和数据区，数据区又分为stack栈内存和heap堆内存;js拥有全局作用域(window)、函数作用域、块级作用域(es6);当查找一个变量时，如果当前作用域没找到该变量，代码会继续往上一个作用域查找(可以理解为更大的大括号)，直到最外层的全局作用域为止，这就是所谓的作用域链。
  2. js的原型是通过函数的prototype属性来实现的，每一个函数都有一个隐藏属性prototype，普通对象是没有prototype属性的(比如：let a = {})。prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即person.__proto__ === Person.prototype。原型链是通过另一个隐藏属性[[prototype]]或叫__proto__来实现的，每一个对象都有这个隐藏属性。
      ```
      Object.prototype.objCustom = function() {}; 
      Object.prototype.arrCustom = 123
      Array.prototype.arrCustom = 456;
      function a() {
        let arr = [3, 5, 7];
        arr.foo = 'hello';
        console.log(arr.objCustom, arr.arrCustom, arr)
      }
      a() // [Function] 456 [ 3, 5, 7, foo: 'hello' ]
      // 解析: 首先在函数作用域中查找arr变量是存在的，接着找arr是否存在objCustom和arrCustom两个属性，变量arr本身是没有这两个属性，但是它是一个Array类型的变量，于是它通过原型链proto找到Array.prototype，Array.prototype存在arrCustom找到后不会继续查找该属性。objCustom属性在Array.prototype中也不存在，但是Array.prototype也是一个对象，里面也存在一个proto，所以继续查找，找到了最顶层的Object.prototype，此时找到了objCustom属性，若没找到则输出undefined。这个查找对象属性的过程就是原型链，通过proto实现。
      ```
  3. 当访问一个对象的属性时，若该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象(父对象)里找，一直找直到__proto__属性的终点null，再往上找就相当于在null上取值会报错，以上这种通过__proto__属性将对象连接起来的这条链路即为所谓的原型链。   
  4. 找变量会涉及到作用域链；找对象属性涉及的是原型链。
   
#### js内部运行机制
  1. 当浏览器(它的内核/引擎)渲染和解析js的时候会提供一个供js代码运行的环境，我们把这个环境称为'全局作用域'。
  2. 代码自上而下执行。
     - 基本数据类型的值会存储在当前作用域下。基本数据类型(值类型)是按照值来操作的，把原有的值复制一份放到新的空间或位置上和原来的值没有关系。
        ```
        // var a = 1;
        // 1. 首先开辟一个空间存储1
        // 2. 在当前作用域中声明一个变量a
        // 3. 让声明的变量和存储的1进行关联(把存储的1赋值给a，该赋值操作叫做定义)
        ``` 
     - 引用数据类型的值不能直接存储到当前的作用域下(因为可能存储的内容过于复杂)，我们需要先开辟一个新的空间(理解为仓库)，把内容存储到这个空间中。引用类型不是按值来操作，它操作的是空间的引用地址，把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆，还是一个空间，这样就会出现多个变量关联的是相同的空间，相互间存在影响。
        ```
        // var obj = {a: 100};
        // 1. 首先开辟一个新的内存空间，把对象中的键值对依次存储起来(为了保证后面可以找到这个空间，此空间有一个16进制的地址)
        // 2. 声明一个变量
        // 3. 让变量和空间地址关联在一起(把空间地址赋值给变量)
        ``` 
  3. 栈内存本身就是一个供js代码执行的环境，所有基本类型值都会直接在栈内存中开辟一个位置进行存储；堆内存独立于栈内存，用来存储引用类型中的信息值，对象存储的是键值对，函数存储的是代码字符串。

#### 闭包
  1. 定义和用法
     - 闭包指的是一个函数可以访问另一个函数作用域中变量。常见的闭包是在一个函数内部定义另外一个函数，内部函数可以引用外层的变量，外层变量不会被垃圾回收机制回收。当一个函数的返回值是另外一个函数，而返回的那个函数调用了其父函数内部的其它变量，若返回的这个函数在外部被执行就产生了闭包。
     - 当内部函数在定义它的作用域的外部被引用(使用)时，就创建了该内部函数的闭包，如果内部函数引用了位于父级函数的变量或其他数据时，当父级函数调用完毕后这些变量数据在内存中不会被GC释放，因为它们被一直饮用着，否则两者没有交互就不会长久存在于内存中，所以在Chrome中debug找不到闭包。
     - 通过调用闭包的内部函数获取到闭包的成员变量，在闭包中返回该函数，在外部接收该函数并执行就能获取闭包的成员变量。原因时因为词法作用域，也就是函数的作用域是其声明的作用域而不是执行调用时的作用域。
  2. 实例如下：
      ```
      // 依据作用域的规则，底层作用域没有声明的变量会向上一级找，找到就返回没找到就一直找直到window的变量，没有就返回undefined。
      var count = 10; // 全局作用域，标记为flag1
      function add() {
        var count = 0; // 函数全局作用域，标记为flag2
        return function() {
          count+=1; // 函数内部作用域
          console.log('count:', count);
        }
      }
      var s = add();
      s(); // 1
      s(); // 2
      ```
  3. 变量的作用域(全局变量和局部变量)
      ```
      1. 函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。
      2. 函数内部声明变量的时候一定要使用var，如果不使用的话实际上声明了一个全局变量
      ```
  4. 注意点：
      ```
      1. 滥用闭包会造成内存泄漏，由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，可能会造成网页的性能问题，解决方法是在退出函数之前将不使用的局部变量全部删除。
      2. 会改变父函数内部变量的值，所以若把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心不要随便改变父函数内部变量的值。
      3. 一个闭包内对变量的修改不会影响到另外一个闭包中的变量。
      4. 闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。
      ```

#### 内存泄漏
  1. 定义：内存泄漏是指一块被分配的内存既不能使用又不能回收，直到浏览器进程结束。浏览器中也是采用自动垃圾回收方法管理内存但浏览器垃圾回收方法有bug会产生内存泄漏。
  2. 内存泄漏常见情况：
     - 页面中元素被移除或替换时，若元素绑定的事件仍没被移除，此时需要先手工移除事件，不然会存在内存泄漏。
     - 函数内定义函数，并且内部函数事件回调引用外部变量形成了闭包，闭包可维持函数内局部变量，使其得不到释放。

#### 性能优化
  1. v-show与v-if使用
  2. for循环添加key
  3. 路由离开及时销毁定时器和解绑事件，移除自己添加的监听事件等
  4. keep-alive缓存页面
  5. 节流(throttle)，防抖(debounce)
  6. 懒加载(路由、图片等)，异步组件
  7. 第三方插件若非必要按需引入避免加载全部
  8. 打包配置优化
  9. cdn
  10. 减低页面加载时间
      - 压缩css、js文件
      - 合并js、css文件，减少http请求
      - 外部js、css文件放在最底下
      - 减少dom操作，尽可能用变量替代不必要的dom操作

####